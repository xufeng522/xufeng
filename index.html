<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>水墨动物消消乐</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .game-container {
            width: 100%;
            max-width: 500px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
            border: 2px solid #e0e0e0;
        }

        /* 得分栏样式 */
        .score-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border-radius: 15px;
            color: white;
            flex-wrap: wrap;
            gap: 10px;
            border: 2px solid #1a252f;
        }

        .score-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .current-score, .best-score {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }

        .label {
            font-weight: bold;
            opacity: 0.9;
        }

        .value {
            font-size: 16px;
            font-weight: bold;
            color: #f1c40f;
        }

        .next-pieces {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .next-pieces-container {
            display: flex;
            gap: 5px;
        }

        .next-piece {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            font-weight: bold;
        }

        .restart-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
            border: 2px solid #c0392b;
        }

        .restart-btn:hover, .restart-btn:active {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }

        /* 游戏棋盘样式 - 黑白水墨风格 */
        .game-board {
            display: grid;
            gap: 2px;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 10px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            border: 3px solid #000;
        }

        .game-board.size-9 {
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
        }

        .game-board.size-8 {
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
        }

        .cell {
            aspect-ratio: 1;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            border: 1px solid #d0d0d0;
        }

        .cell:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .cell.selected {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
            border: 2px solid #2980b9;
        }

        .cell.valid-move {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            animation: pulse 1s infinite;
            border: 2px solid #27ae60;
        }

        .cell.path {
            background: #b3c6e0cc; /* 淡蓝色，带透明度 */
            border: 2px solid #5d6d7e;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* 棋子样式 - 黑白水墨风格 */
        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            transition: all 0.3s ease;
            position: relative;
            border: 3px solid rgba(0, 0, 0, 0.3);
        }

        .piece.eliminating {
            animation: eliminate 0.5s ease-out;
        }

        @keyframes eliminate {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* 动物棋子颜色 - 黑白水墨风格 */
        .piece[data-type="tiger"] {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border-color: #1a252f;
        }

        .piece[data-type="dragon"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            border-color: #000;
        }

        .piece[data-type="phoenix"] {
            background: linear-gradient(135deg, #7f8c8d 0%, #95a5a6 100%);
            border-color: #5d6d7e;
        }

        .piece[data-type="turtle"] {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            border-color: #1a252f;
        }

        .piece[data-type="crane"] {
            background: linear-gradient(135deg, #5d6d7e 0%, #7f8c8d 100%);
            border-color: #34495e;
        }

        .piece[data-type="panda"] {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
            border-color: #5d6d7e;
        }



        .difficulty-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .difficulty-selector label {
            font-size: 14px;
            font-weight: bold;
            color: white;
        }

        .difficulty-select {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            padding: 4px 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .difficulty-select:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .difficulty-select option {
            background: #2c3e50;
            color: white;
        }

        /* 礼花效果 */
        .firework {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            animation: firework 2s ease-out forwards;
        }

        @keyframes firework {
            0% {
                transform: scale(0);
                opacity: 1;
                background: #ff6b6b;
            }
            50% {
                transform: scale(1);
                opacity: 1;
                background: #4ecdc4;
            }
            100% {
                transform: scale(0);
                opacity: 0;
                background: #45b7d1;
            }
        }

        /* 等级显示样式 */
        .level-display {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }

        .level-badge {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            font-weight: bold;
        }

        /* 控制行样式 */
        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .control-row .level-display {
            margin: 0;
        }

        .control-row .difficulty-selector {
            margin: 0;
        }

        .control-row .restart-btn {
            margin: 0;
        }

        /* 游戏结束模态框 */
        .game-over-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 300px;
            width: 90%;
            border: 3px solid #2c3e50;
        }

        .modal-content h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 24px;
        }

        .modal-content p {
            color: #7f8c8d;
            margin-bottom: 20px;
            font-size: 16px;
        }

        /* 响应式设计 */
        @media (max-width: 480px) {
            .game-container {
                padding: 15px;
                margin: 10px;
            }

            .score-panel {
                flex-direction: column;
                align-items: stretch;
                gap: 15px;
            }

            .score-info {
                flex-direction: row;
                justify-content: space-between;
            }

            .next-pieces {
                justify-content: center;
            }

            .game-board {
                gap: 1px;
                padding: 8px;
            }

            .cell {
                border-radius: 6px;
            }

            .piece {
                font-size: 16px;
            }
        }

        /* 水墨风格装饰 */
        .game-container::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: linear-gradient(45deg, transparent 30%, rgba(0, 0, 0, 0.1) 50%, transparent 70%);
            border-radius: 25px;
            z-index: -1;
            animation: shimmer 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }

        /* 音效控制 */
        .sound-control {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 1001;
            font-size: 20px;
        }

        .sound-control:hover {
            background: rgba(0, 0, 0, 0.9);
        } 

        .bgm-control {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 1001;
            font-size: 22px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            transition: background 0.2s;
        }
        .bgm-control:hover {
            background: rgba(0, 0, 0, 0.9);
        } 
    </style>
</head>
<body>
    <!-- 背景音乐控制按钮 -->
    <button class="bgm-control" id="bgmControl">🔊</button>
    <!-- 背景音乐（中国风BGM，示例用网络可用的免费BGM） -->
    <audio id="bgm" loop preload="auto">
        <source src="https://cdn.pixabay.com/audio/2022/10/16/audio_12b6b8b6b2.mp3" type="audio/mp3">
    </audio>
    <!-- 音效控制按钮（仅保留消除音效，不再控制） -->
    <button class="sound-control" id="soundControl" style="display:none">🔊</button>
    
    <div class="game-container" id="gameContainer">
        <!-- 得分栏 -->
        <div class="score-panel">
            <div class="score-info">
                <div class="current-score">
                    <span class="label">得分:</span>
                    <span class="value" id="currentScore">0</span>
                </div>
                <div class="best-score">
                    <span class="label">历史记录:</span>
                    <span class="value" id="bestScore">0</span>
                </div>
            </div>
            
            <!-- 预生成棋子 -->
            <div class="next-pieces">
                <span class="label">下次投放:</span>
                <div class="next-pieces-container" id="nextPieces">
                    <div class="next-piece" data-type=""></div>
                    <div class="next-piece" data-type=""></div>
                    <div class="next-piece" data-type=""></div>
                </div>
            </div>
            
            <div class="control-row">
                <div class="level-display">
                    <span class="label">等级:</span>
                    <span class="level-badge" id="levelDisplay">青铜</span>
                </div>
                <div class="difficulty-selector">
                    <label for="difficultySelect">难度:</label>
                    <select id="difficultySelect" class="difficulty-select">
                        <option value="normal">正常</option>
                        <option value="medium">中等</option>
                        <option value="hard">困难</option>
                    </select>
                </div>
                <button class="restart-btn" id="restartBtn">重新开始</button>
            </div>
        </div>
        
        <!-- 游戏棋盘 -->
        <div class="game-board" id="gameBoard">
            <!-- 9x9棋盘格子将通过JavaScript动态生成 -->
        </div>
        
        <!-- 游戏结束提示 -->
        <div class="game-over-modal" id="gameOverModal">
            <div class="modal-content">
                <h2>游戏结束</h2>
                <p>最终得分: <span id="finalScore">0</span></p>
                <button class="restart-btn" id="modalRestartBtn">重新开始</button>
            </div>
        </div>
    </div>
    
    <!-- 音效文件 -->
    <audio id="eliminateSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT" type="audio/wav">
    </audio>
    <audio id="moveSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT" type="audio/wav">
    </audio>
    <audio id="selectSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT" type="audio/wav">
    </audio>
    
    <script>
        class AnimalMatchGame {
            constructor(difficulty = 'normal') {
                this.difficulty = difficulty;
                this.setDifficulty(difficulty);
                this.board = [];
                this.currentScore = 0;
                this.bestScore = localStorage.getItem('bestScore') || 0;
                this.nextPieces = [];
                this.selectedCell = null;
                this.gameOver = false;
                this.soundEnabled = localStorage.getItem('soundEnabled') !== 'false';
                
                // 等级系统
                this.playerLevel = this.getPlayerLevel();
                this.currentLevel = this.calculateLevel(this.currentScore);
                
                // 加载游戏状态
                this.loadGameState();
                
                this.init();
            }
            
            // 计算玩家等级
            calculateLevel(score) {
                if (score <= 3000) return '青铜';
                if (score <= 5000) return '黄金';
                if (score <= 7000) return '铂金';
                if (score <= 12000) return '钻石';
                if (score <= 16000) return '星耀';
                return '王者';
            }
            
            // 获取玩家最高等级
            getPlayerLevel() {
                const savedLevel = localStorage.getItem('playerLevel') || '青铜';
                return savedLevel;
            }
            
            // 保存游戏状态
            saveGameState() {
                const gameState = {
                    board: this.board,
                    currentScore: this.currentScore,
                    nextPieces: this.nextPieces,
                    difficulty: this.difficulty,
                    gameOver: this.gameOver
                };
                localStorage.setItem('gameState', JSON.stringify(gameState));
            }
            
            // 加载游戏状态
            loadGameState() {
                const savedState = localStorage.getItem('gameState');
                if (savedState) {
                    try {
                        const state = JSON.parse(savedState);
                        // 只有当难度相同时才加载状态
                        if (state.difficulty === this.difficulty && !state.gameOver) {
                            this.board = state.board;
                            this.currentScore = state.currentScore;
                            this.nextPieces = state.nextPieces;
                            this.gameOver = state.gameOver;
                            return true;
                        }
                    } catch (e) {
                        console.log('加载游戏状态失败:', e);
                    }
                }
                return false;
            }
            
            // 清除游戏状态
            clearGameState() {
                localStorage.removeItem('gameState');
            }
            
            setDifficulty(difficulty) {
                switch(difficulty) {
                    case 'normal':
                        this.boardSize = 9;
                        this.animalTypes = ['tiger', 'dragon', 'phoenix', 'turtle', 'crane'];
                        break;
                    case 'medium':
                        this.boardSize = 8;
                        this.animalTypes = ['tiger', 'dragon', 'phoenix', 'turtle', 'crane'];
                        break;
                    case 'hard':
                        this.boardSize = 9;
                        this.animalTypes = ['tiger', 'dragon', 'phoenix', 'turtle', 'crane', 'panda'];
                        break;
                    default:
                        this.boardSize = 9;
                        this.animalTypes = ['tiger', 'dragon', 'phoenix', 'turtle', 'crane'];
                }
                
                this.animalSymbols = {
                    'tiger': '🐯',
                    'dragon': '🐉',
                    'phoenix': '🦅',
                    'turtle': '🐢',
                    'crane': '🦢',
                    'panda': '🐼'
                };
            }
            
            init() {
                this.createBoard();
                this.updateScoreDisplay();
                
                // 检查是否有保存的游戏状态
                const hasSavedState = this.loadGameState();
                
                if (hasSavedState) {
                    // 恢复棋盘状态
                    this.restoreBoard();
                    this.updateNextPiecesDisplay();
                } else {
                    // 开始新游戏
                    this.generateNextPieces();
                    this.placeInitialPieces();
                }
                
                this.bindEvents();
                this.updateSoundControl();
            }
            
            // 恢复棋盘状态
            restoreBoard() {
                for (let row = 0; row < this.boardSize; row++) {
                    for (let col = 0; col < this.boardSize; col++) {
                        if (this.board[row][col] !== null) {
                            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                            if (cell) {
                                const piece = document.createElement('div');
                                piece.className = 'piece';
                                piece.dataset.type = this.board[row][col];
                                piece.textContent = this.animalSymbols[this.board[row][col]];
                                cell.appendChild(piece);
                            }
                        }
                    }
                }
            }
            
            createBoard() {
                const gameBoard = document.getElementById('gameBoard');
                gameBoard.innerHTML = '';
                
                // 设置棋盘大小类名
                gameBoard.className = `game-board size-${this.boardSize}`;
                
                for (let row = 0; row < this.boardSize; row++) {
                    this.board[row] = [];
                    for (let col = 0; col < this.boardSize; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        gameBoard.appendChild(cell);
                        this.board[row][col] = null;
                    }
                }
            }
            
            generateNextPieces() {
                this.nextPieces = [];
                for (let i = 0; i < 3; i++) {
                    this.nextPieces.push(this.getRandomAnimalType());
                }
                this.updateNextPiecesDisplay();
            }
            
            getRandomAnimalType() {
                return this.animalTypes[Math.floor(Math.random() * this.animalTypes.length)];
            }
            
            updateNextPiecesDisplay() {
                const nextPiecesContainer = document.getElementById('nextPieces');
                const nextPieceElements = nextPiecesContainer.children;
                
                for (let i = 0; i < 3; i++) {
                    const pieceElement = nextPieceElements[i];
                    const animalType = this.nextPieces[i];
                    pieceElement.dataset.type = animalType;
                    pieceElement.textContent = this.animalSymbols[animalType];
                }
            }
            
            placeInitialPieces() {
                // 随机放置3个初始棋子
                for (let i = 0; i < 3; i++) {
                    this.placeRandomPiece();
                }
            }
            
            placeRandomPiece() {
                const emptyCells = this.getEmptyCells();
                if (emptyCells.length === 0) return false;
                
                // 确保有可用的棋子类型
                if (this.nextPieces.length === 0) {
                    this.generateNextPieces();
                }
                
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                const animalType = this.nextPieces.shift();
                
                if (animalType) {
                    this.placePiece(randomCell.row, randomCell.col, animalType);
                    return true;
                }
                
                return false;
            }
            
            async placeThreePieces() {
                // 记录新投放棋子的坐标
                const newPieces = [];
                for (let i = 0; i < 3; i++) {
                    const pos = this.placeRandomPieceWithPos();
                    if (pos) newPieces.push(pos);
                    else break;
                }
                this.generateNextPieces();
                // 检查所有新投放棋子的消除
                let eliminated = new Set();
                for (const {row, col} of newPieces) {
                    const toEliminate = this.checkElimination(row, col);
                    toEliminate.forEach(pos => eliminated.add(pos));
                }
                if (eliminated.size > 0) {
                    // 转为数组并消除
                    this.eliminatePieces(Array.from(eliminated));
                    // 消除后不再投放新棋子
                    return;
                }
            }

            // 返回投放棋子的坐标
            placeRandomPieceWithPos() {
                const emptyCells = this.getEmptyCells();
                if (emptyCells.length === 0) return null;
                if (this.nextPieces.length === 0) {
                    this.generateNextPieces();
                }
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                const animalType = this.nextPieces.shift();
                if (animalType) {
                    this.placePiece(randomCell.row, randomCell.col, animalType);
                    return { row: randomCell.row, col: randomCell.col };
                }
                return null;
            }
            
            getEmptyCells() {
                const emptyCells = [];
                for (let row = 0; row < this.boardSize; row++) {
                    for (let col = 0; col < this.boardSize; col++) {
                        if (this.board[row][col] === null) {
                            emptyCells.push({ row, col });
                        }
                    }
                }
                return emptyCells;
            }
            
            placePiece(row, col, animalType) {
                if (this.board[row][col] !== null) return false;
                
                this.board[row][col] = animalType;
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                
                const piece = document.createElement('div');
                piece.className = 'piece';
                piece.dataset.type = animalType;
                piece.textContent = this.animalSymbols[animalType];
                
                cell.appendChild(piece);
                return true;
            }
            
            bindEvents() {
                const gameBoard = document.getElementById('gameBoard');
                
                // 清除之前的事件监听器
                const newGameBoard = gameBoard.cloneNode(true);
                gameBoard.parentNode.replaceChild(newGameBoard, gameBoard);
                
                newGameBoard.addEventListener('click', (e) => {
                    if (this.gameOver) return;
                    
                    const cell = e.target.closest('.cell');
                    if (!cell) return;
                    
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    
                    this.handleCellClick(row, col);
                });
            }
            
            updateSoundControl() {
                const soundControl = document.getElementById('soundControl');
                soundControl.textContent = this.soundEnabled ? '🔊' : '🔇';
            }
            
            playSound(soundId) {
                // 消除音效始终播放
                if (soundId === 'eliminateSound') {
                    const audio = document.getElementById(soundId);
                    if (audio) {
                        audio.currentTime = 0;
                        audio.play().catch(e => {});
                    }
                    return;
                }
                // 其它音效受静音控制
                if (!this.soundEnabled) return;
                const audio = document.getElementById(soundId);
                if (audio) {
                    audio.currentTime = 0;
                    audio.play().catch(e => {});
                }
            }
            
            handleCellClick(row, col) {
                if (this.board[row][col] !== null) {
                    // 点击有棋子的格子
                    this.selectCell(row, col);
                } else if (this.selectedCell) {
                    // 点击空格子，先显示路径，然后移动棋子
                    this.showPathToTarget(row, col);
                    setTimeout(() => {
                        this.movePiece(this.selectedCell.row, this.selectedCell.col, row, col);
                    }, 500); // 显示路径0.5秒后移动
                }
            }
            
            selectCell(row, col) {
                // 清除之前的选择
                this.clearSelection();
                
                this.selectedCell = { row, col };
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                cell.classList.add('selected');
                
                // 播放选择音效
                this.playSound('selectSound');
                
                // 显示可移动的路径
                this.showValidMoves(row, col);
            }
            
            clearSelection() {
                if (this.selectedCell) {
                    const cell = document.querySelector(`[data-row="${this.selectedCell.row}"][data-col="${this.selectedCell.col}"]`);
                    cell.classList.remove('selected');
                }
                
                // 清除所有路径显示
                document.querySelectorAll('.cell.path').forEach(cell => {
                    cell.classList.remove('path');
                });
                
                this.selectedCell = null;
                this.validMoves = null;
            }
            
            showValidMoves(startRow, startCol) {
                const validMoves = this.findValidMoves(startRow, startCol);
                
                // 不显示任何提示，只记录可移动位置
                this.validMoves = validMoves;
                
                // 调试信息
                console.log(`找到 ${validMoves.length} 个可移动位置`);
            }
            
            showPathToTarget(targetRow, targetCol) {
                // 清除之前的路径显示
                document.querySelectorAll('.cell.path').forEach(cell => {
                    cell.classList.remove('path');
                });
                
                if (!this.selectedCell || !this.validMoves) return;
                
                const targetMove = this.validMoves.find(move => move.row === targetRow && move.col === targetCol);
                
                if (targetMove && targetMove.path.length > 0) {
                    // 显示最短路径
                    targetMove.path.forEach(pathStep => {
                        const pathCell = document.querySelector(`[data-row="${pathStep.row}"][data-col="${pathStep.col}"]`);
                        if (pathCell) {
                            pathCell.classList.add('path');
                        }
                    });
                    
                    console.log(`显示到 (${targetRow}, ${targetCol}) 的路径:`, targetMove.path);
                } else {
                    console.log(`无法移动到 (${targetRow}, ${targetCol})`);
                }
            }
            
            findValidMoves(startRow, startCol) {
                const validMoves = [];
                const visited = new Set();
                const queue = [{ row: startRow, col: startCol, path: [] }];
                
                // 标记起点为已访问
                visited.add(`${startRow},${startCol}`);
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    
                    // 检查四个方向
                    const directions = [
                        { row: -1, col: 0 }, // 上
                        { row: 1, col: 0 },  // 下
                        { row: 0, col: -1 }, // 左
                        { row: 0, col: 1 }   // 右
                    ];
                    
                    directions.forEach(dir => {
                        const newRow = current.row + dir.row;
                        const newCol = current.col + dir.col;
                        const newKey = `${newRow},${newCol}`;
                        
                        // 检查是否有效位置且未访问过且为空
                        if (this.isValidPosition(newRow, newCol) && 
                            !visited.has(newKey) && 
                            this.board[newRow][newCol] === null) {
                            
                            visited.add(newKey);
                            const newPath = [...current.path, { row: newRow, col: newCol }];
                            
                            // 添加到有效移动列表
                            validMoves.push({ row: newRow, col: newCol, path: newPath });
                            
                            // 继续从这个位置搜索
                            queue.push({ row: newRow, col: newCol, path: newPath });
                        }
                    });
                }
                
                // 调试信息
                console.log(`从 (${startRow}, ${startCol}) 找到 ${validMoves.length} 个可移动位置`);
                validMoves.forEach(move => {
                    console.log(`  可移动到 (${move.row}, ${move.col})，路径长度: ${move.path.length}`);
                });
                
                return validMoves;
            }
            
            isValidPosition(row, col) {
                return row >= 0 && row < this.boardSize && col >= 0 && col < this.boardSize;
            }
            
            async movePiece(fromRow, fromCol, toRow, toCol) {
                const validMoves = this.findValidMoves(fromRow, fromCol);
                const targetMove = validMoves.find(move => move.row === toRow && move.col === toCol);
                if (!targetMove) {
                    this.clearSelection();
                    return false;
                }
                // 播放移动音效
                this.playSound('moveSound');
                // 获取路径
                const path = targetMove.path;
                // 移动前清除橙色路径提示
                document.querySelectorAll('.cell.path').forEach(cell => cell.classList.remove('path'));
                // 动画逐步移动
                let curRow = fromRow, curCol = fromCol;
                const animalType = this.board[fromRow][fromCol];
                const piece = document.querySelector(`[data-row="${fromRow}"][data-col="${fromCol}"] .piece`);
                for (const step of path) {
                    // 清除当前位置
                    this.board[curRow][curCol] = null;
                    const fromCell = document.querySelector(`[data-row="${curRow}"][data-col="${curCol}"]`);
                    if (fromCell && fromCell.contains(piece)) fromCell.removeChild(piece);
                    // 移动到下一步
                    this.board[step.row][step.col] = animalType;
                    const toCell = document.querySelector(`[data-row="${step.row}"][data-col="${step.col}"]`);
                    toCell.appendChild(piece);
                    curRow = step.row;
                    curCol = step.col;
                    // 等待动画
                    await new Promise(res => setTimeout(res, 30));
                }
                // 最终位置
                this.clearSelection();
                // 检查消除
                const eliminatedPieces = this.checkElimination(toRow, toCol);
                if (eliminatedPieces.length > 0) {
                    this.eliminatePieces(eliminatedPieces);
                    // 有消除时不投放新棋子
                } else {
                    // 没有消除时投放3个新棋子
                    await this.placeThreePieces();
                }
                // 保存游戏状态
                this.saveGameState();
                // 检查游戏是否结束
                if (this.isGameOver()) {
                    this.endGame();
                }
                return true;
            }
            
            checkElimination(row, col) {
                const animalType = this.board[row][col];
                const eliminatedPieces = new Set();
                // 四个方向：横、竖、主对角线、副对角线
                const directions = [
                    { dr: 0, dc: 1 },   // 横向
                    { dr: 1, dc: 0 },   // 纵向
                    { dr: 1, dc: 1 },   // 主对角线
                    { dr: 1, dc: -1 }   // 副对角线
                ];
                for (const {dr, dc} of directions) {
                    const line = [{ row, col }];
                    // 向正方向扩展
                    let r = row + dr, c = col + dc;
                    while (this.isValidPosition(r, c) && this.board[r][c] === animalType) {
                        line.push({ row: r, col: c });
                        r += dr;
                        c += dc;
                    }
                    // 向反方向扩展
                    r = row - dr; c = col - dc;
                    while (this.isValidPosition(r, c) && this.board[r][c] === animalType) {
                        line.unshift({ row: r, col: c });
                        r -= dr;
                        c -= dc;
                    }
                    // 满足5连及以上
                    if (line.length >= 5) {
                        line.forEach(pos => eliminatedPieces.add(`${pos.row},${pos.col}`));
                    }
                }
                return Array.from(eliminatedPieces);
            }
            
            checkLine(startRow, startCol, deltaRow, deltaCol, animalType, eliminatedPieces) {
                let count = 0;
                const line = [];
                
                // 向前检查
                for (let i = 0; i < this.boardSize; i++) {
                    const row = startRow + i * deltaRow;
                    const col = startCol + i * deltaCol;
                    
                    if (!this.isValidPosition(row, col)) break;
                    
                    if (this.board[row][col] === animalType) {
                        count++;
                        line.push({ row, col });
                    } else {
                        break;
                    }
                }
                
                // 向后检查
                for (let i = 1; i < this.boardSize; i++) {
                    const row = startRow - i * deltaRow;
                    const col = startCol - i * deltaCol;
                    
                    if (!this.isValidPosition(row, col)) break;
                    
                    if (this.board[row][col] === animalType) {
                        count++;
                        line.push({ row, col });
                    } else {
                        break;
                    }
                }
                
                if (count >= 5) {
                    line.forEach(pos => eliminatedPieces.add(`${pos.row},${pos.col}`));
                }
            }
            
            checkDiagonal(row, col, animalType, eliminatedPieces) {
                // 检查主对角线
                this.checkLine(row, col, -1, -1, animalType, eliminatedPieces);
                this.checkLine(row, col, 1, 1, animalType, eliminatedPieces);
                
                // 检查副对角线
                this.checkLine(row, col, -1, 1, animalType, eliminatedPieces);
                this.checkLine(row, col, 1, -1, animalType, eliminatedPieces);
            }
            
            eliminatePieces(eliminatedPieces) {
                const score = eliminatedPieces.length * 10;
                this.currentScore += score;
                this.updateScoreDisplay();
                
                // 播放消除音效
                this.playSound('eliminateSound');
                
                eliminatedPieces.forEach(posStr => {
                    const [row, col] = posStr.split(',').map(Number);
                    this.board[row][col] = null;
                    
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    const piece = cell.querySelector('.piece');
                    
                    if (piece) {
                        piece.classList.add('eliminating');
                        setTimeout(() => {
                            if (piece.parentNode) {
                                piece.parentNode.removeChild(piece);
                            }
                        }, 500);
                    }
                });
                
                // 保存游戏状态
                this.saveGameState();
            }
            
            isGameOver() {
                // 检查是否还有空格子
                const emptyCells = this.getEmptyCells();
                if (emptyCells.length === 0) return true;
                
                // 检查是否还有可移动的棋子
                for (let row = 0; row < this.boardSize; row++) {
                    for (let col = 0; col < this.boardSize; col++) {
                        if (this.board[row][col] !== null) {
                            const validMoves = this.findValidMoves(row, col);
                            if (validMoves.length > 0) {
                                return false;
                            }
                        }
                    }
                }
                
                return true;
            }
            
            endGame() {
                this.gameOver = true;
                
                // 更新最高分
                if (this.currentScore > this.bestScore) {
                    this.bestScore = this.currentScore;
                    localStorage.setItem('bestScore', this.bestScore);
                    this.updateScoreDisplay();
                }
                
                // 清除游戏状态
                this.clearGameState();
                
                // 显示游戏结束模态框
                const modal = document.getElementById('gameOverModal');
                const finalScore = document.getElementById('finalScore');
                finalScore.textContent = this.currentScore;
                modal.style.display = 'flex';
            }
            
            updateScoreDisplay() {
                document.getElementById('currentScore').textContent = this.currentScore;
                document.getElementById('bestScore').textContent = this.bestScore;
                
                // 更新等级显示
                const newLevel = this.calculateLevel(this.currentScore);
                if (newLevel !== this.currentLevel) {
                    this.currentLevel = newLevel;
                    this.checkLevelUp();
                }
                
                // 显示当前等级
                this.updateLevelDisplay();
            }
            
            // 检查等级提升
            checkLevelUp() {
                const levelOrder = ['青铜', '黄金', '铂金', '钻石', '星耀', '王者'];
                const currentIndex = levelOrder.indexOf(this.currentLevel);
                const playerIndex = levelOrder.indexOf(this.playerLevel);
                
                if (currentIndex > playerIndex) {
                    // 等级提升
                    this.playerLevel = this.currentLevel;
                    localStorage.setItem('playerLevel', this.playerLevel);
                    this.showLevelUpEffect();
                }
            }
            
            // 显示等级提升效果
            showLevelUpEffect() {
                // 创建礼花效果
                this.createFireworks();
                
                // 显示等级提升提示
                setTimeout(() => {
                    alert(`🎉 恭喜您升级到 ${this.playerLevel} 等级！`);
                }, 1000);
            }
            
            // 创建礼花效果
            createFireworks() {
                const container = document.querySelector('.game-container');
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        this.createFirework(container);
                    }, i * 100);
                }
            }
            
            // 创建单个礼花
            createFirework(container) {
                const firework = document.createElement('div');
                firework.className = 'firework';
                firework.style.left = Math.random() * 100 + '%';
                firework.style.top = Math.random() * 100 + '%';
                firework.style.animationDelay = Math.random() * 0.5 + 's';
                container.appendChild(firework);
                
                setTimeout(() => {
                    if (firework.parentNode) {
                        firework.parentNode.removeChild(firework);
                    }
                }, 2000);
            }
            
            // 更新等级显示
            updateLevelDisplay() {
                const levelDisplay = document.getElementById('levelDisplay');
                if (levelDisplay) {
                    levelDisplay.textContent = this.currentLevel;
                }
            }
            
            restartGame() {
                this.board = [];
                this.currentScore = 0;
                this.nextPieces = [];
                this.selectedCell = null;
                this.validMoves = null;
                this.gameOver = false;
                
                // 清除游戏状态
                this.clearGameState();
                
                // 隐藏模态框
                document.getElementById('gameOverModal').style.display = 'none';
                
                this.init();
            }
            
            // 自我测试函数
            selfTest() {
                console.log('=== 开始自我测试 ===');
                
                // 测试1: 检查路径算法
                this.testPathAlgorithm();
                
                // 测试2: 检查棋子显示
                this.testPieceDisplay();
                
                // 测试3: 检查移动逻辑
                this.testMoveLogic();
                
                console.log('=== 自我测试完成 ===');
            }
            
            testPathAlgorithm() {
                console.log('测试路径算法...');
                
                // 清空棋盘进行测试
                this.board = [];
                for (let row = 0; row < this.boardSize; row++) {
                    this.board[row] = [];
                    for (let col = 0; col < this.boardSize; col++) {
                        this.board[row][col] = null;
                    }
                }
                
                // 在中心放置一个棋子
                this.board[4][4] = 'tiger';
                
                // 测试路径查找
                const moves = this.findValidMoves(4, 4);
                console.log(`从中心位置找到 ${moves.length} 个可移动位置`);
                
                // 验证是否包含远距离位置
                const hasFarMove = moves.some(move => {
                    const distance = Math.abs(move.row - 4) + Math.abs(move.col - 4);
                    return distance > 1;
                });
                
                if (hasFarMove) {
                    console.log('✅ 路径算法正确：支持多格移动');
                } else {
                    console.log('❌ 路径算法错误：只能移动一格');
                }
                
                // 恢复棋盘
                this.init();
            }
            
            testPieceDisplay() {
                console.log('测试棋子显示...');
                
                // 检查棋子是否正确显示
                const pieces = document.querySelectorAll('.piece');
                let displayCorrect = true;
                
                pieces.forEach(piece => {
                    const type = piece.dataset.type;
                    const symbol = piece.textContent;
                    
                    if (!type || !symbol || symbol !== this.animalSymbols[type]) {
                        displayCorrect = false;
                        console.log(`❌ 棋子显示错误: type=${type}, symbol=${symbol}`);
                    }
                });
                
                if (displayCorrect) {
                    console.log('✅ 棋子显示正确');
                } else {
                    console.log('❌ 棋子显示有问题');
                }
            }
            
            testMoveLogic() {
                console.log('测试移动逻辑...');
                
                // 检查是否有选中的棋子
                if (this.selectedCell) {
                    console.log(`✅ 有选中的棋子: (${this.selectedCell.row}, ${this.selectedCell.col})`);
                } else {
                    console.log('ℹ️ 当前没有选中的棋子');
                }
                
                // 检查可移动位置
                if (this.validMoves) {
                    console.log(`✅ 有 ${this.validMoves.length} 个可移动位置`);
                } else {
                    console.log('ℹ️ 当前没有可移动位置');
                }
            }
        }

        // 启动游戏
        let game = null;
        let bgmPlaying = false;

        function updateBgmIcon() {
            const bgmControl = document.getElementById('bgmControl');
            if (bgmControl) bgmControl.textContent = bgmPlaying ? '🔊' : '🔈';
        }

        function changeDifficulty() {
            const difficultySelect = document.getElementById('difficultySelect');
            const difficulty = difficultySelect.value;
            
            if (game) {
                // 重新创建游戏实例
                game = new AnimalMatchGame(difficulty);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const bgm = document.getElementById('bgm');
            const bgmControl = document.getElementById('bgmControl');
            
            // 背景音乐控制
            if (bgmControl) {
                bgmControl.onclick = () => {
                    if (bgm.paused) {
                        bgm.play();
                        bgmPlaying = true;
                    } else {
                        bgm.pause();
                        bgmPlaying = false;
                    }
                    updateBgmIcon();
                };
            }
            
            // 页面加载时尝试自动播放
            bgm.play().then(() => {
                bgmPlaying = true;
                updateBgmIcon();
            }).catch(() => {
                // 如果被拦截，等待用户首次点击
                document.body.addEventListener('click', () => {
                    if (!bgmPlaying) {
                        bgm.play().then(()=>{bgmPlaying=true;updateBgmIcon();}).catch(()=>{});
                    }
                }, { once: true });
            });
            updateBgmIcon();
            
            // 难度选择下拉框事件
            document.getElementById('difficultySelect').addEventListener('change', changeDifficulty);
            
            // 重新开始按钮事件
            document.getElementById('restartBtn').addEventListener('click', () => {
                if (game) {
                    game.restartGame();
                }
            });
            
            // 模态框重新开始按钮事件
            document.getElementById('modalRestartBtn').addEventListener('click', () => {
                if (game) {
                    game.restartGame();
                }
            });
            
            // 初始化游戏
            game = new AnimalMatchGame('normal');
        }); 
    </script>
</body>
</html> 
